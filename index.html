<style>
  body {
    margin: 0px;
  }
  
  .circle {
    /* border-radius: 50%; */
    width: 400px;
    height: 50px;
    display: grid;
    place-content: center;
    background: grey;
    color: white;
    /* transform: translate(-50%, -50%) */
  }
  
  .mover {
    position: fixed;
    z-index: 10;
    border: 3px solid black;
  }
  
  .red {
    background: red;
  }

  .blue {
    background: blue;
  }

</style>

<div 
  q="1" 
  x="100" 
  y="10"  
  on:click="el.vx = 2" 
  on:keyheld:ArrowRight="el.vx = 2" 
  on:keypress:ArrowUp="el.vx = 2" 
  collidable
  func="
    el.ay = 1; 
  
    if (heldKeys['ArrowRight']) {
  
      el.vx = 5;
    }

    if (heldKeys['ArrowLeft']) {
  
      el.vx = -5;
    }


    if (pressedKeys['ArrowUp'] && el.vy < 0.1) {
      el.vy = -20;
    }
  " 
  bounce="0.2"
  friction-x=".3">
  <img width="100px" src="https://hips.hearstapps.com/countryliving.cdnds.net/17/47/1511194376-cavachon-puppy-christmas.jpg"/>
</div>

<div x="300" vx="-2" y="300" bounce="1">
  <div class="circle" style="background: blue;"></div>
</div>

<script defer type="module">
  // const events = document.querySelectorAll(`[on:]`);
  // console.log(events);

  
  const attributes = ["q", "func", "x", "y", "ax", "ay", "vx", "vy"]
  const mags = document.querySelectorAll(`[q]`);
  const collidables = document.querySelectorAll(`[collidable]`);
  const all = attributes.reduce((acc, cur) => [
    ...acc,
    ...document.querySelectorAll(`[${cur}]`)
  ], []);

  let count = 0;
  for (const el of all) {
    if (el.uid !== undefined) continue;
    const styles = window.getComputedStyle(el);
    let trans = styles.getPropertyValue('transform');
    if (trans === "none") trans = "matrix(1, 0, 0, 1, 0, 0)"
    const numbers = trans
      .slice(7, -1)
      .split(",")
      .map(Number);

    if (el.hasAttribute("q")) el.q = Number(el.getAttribute("q"));
    else el.q = 0;
    // else if (el.matches("[mover]")) el.q = -1;

    if (el.hasAttribute("func")) el.func = new Function("el", "w", "h", "mouseX", "mouseY", "step", "heldKeys", "pressedKeys", el.getAttribute("func"));
   
    
    if (el.hasAttribute("x")) numbers[4] = Number(el.getAttribute("x"));
    if (el.hasAttribute("y")) numbers[5] = Number(el.getAttribute("y"));

    el.ax = el.hasAttribute("ax") ? Number(el.getAttribute("ax")) : 0;
    el.ay = el.hasAttribute("ay") ? Number(el.getAttribute("ay")) : 0;
    el.vx = el.hasAttribute("vx") ? Number(el.getAttribute("vx")) : 0;
    el.vy = el.hasAttribute("vy") ? Number(el.getAttribute("vy")) : 0;
    el.x = numbers[4]; // plus width/2
    el.y = numbers[5]; // plus height/2
    
    el.bounce = el.hasAttribute("bounce") ? Number(el.getAttribute("bounce")) : 1/2;
    if (el.hasAttribute("friction")) {
       el.frictionX = Number(el.getAttribute("friction"));
       el.frictionY = Number(el.getAttribute("friction"));
    } else {
      el.frictionX = 0;
      el.frictionY = 0;
    }
    el.frictionX = el.hasAttribute("friction-x") ? Number(el.getAttribute("friction-x")) : ( el.frictionX ?? 0);
    el.frictionY = el.hasAttribute("friction-y") ? Number(el.getAttribute("friction-y")) : ( el.frictionY ?? 0);

    el.name = el.hasAttribute("name") ? el.getAttribute("name") : "";
    el.collidable = el.hasAttribute("collidable");

    el.style.position = "fixed";
    el.style.transform = `matrix(1, 0, 0, 1, ${numbers[4]}, ${numbers[5]})`

    const { width, height } = el.getBoundingClientRect();
    el.width = width;
    el.height = height;

    el.uid = count;
    
    count++;
  }

  function getAngle(cx, cy, ex, ey) {
    var dy = ey - cy;
    var dx = ex - cx;
    var theta = Math.atan2(dy, dx); // range (-PI, PI]
    // theta *= 180 / Math.PI; // rads to degs, range (-180, 180]
    //if (theta < 0) theta = 360 + theta; // range [0, 360)
    return theta;
  }

  const G = 1;
  const SOFTENING = 10;
  
  function calculateForce(index) {
    const el = all[index];
    let x0 = el.x;
    let y0 = el.y;
    
    let fx = 0;
    let fy = 0;
    // could be sped up with symmetry
    for (let i = 0; i < mags.length; i++) {
      if (mags[i].uid === el.uid) continue;
      let x1 = mags[i].x;
      let y1 = mags[i].y;
      const dSquared = (x1 - x0)**2 + (y1 - y0)**2 + SOFTENING**2

      const q0 = el.q; // get from redness/blueness
      const q1 = mags[i].q; // get from redness/blueness

      // why are these different?
      
      // const f = G*mag0*mag1/dSquared;
      // const a = getAngle(x0, y0, x1, y1);
      // fx += f*Math.cos(a);
      // fy += f*Math.sin(a);
      
      const dx = x1 - x0;
      const dy = y1 - y0;
      const inv_r2 = (dx**2 + dy**2 + SOFTENING**2)**(-3/2);

      let attract = 1;
      if (q0 < 0 && q1 < 0) attract = -1;
      if (q0 > 0 && q1 > 0) attract = -1;

      fx += G * Math.abs(q0)*Math.abs(q1) * dx * inv_r2 * attract;
      fy += G * Math.abs(q0)*Math.abs(q1) * dy * inv_r2 * attract;
    }

    return [fx, fy];
  } 

  function haveCollided(el0, el1) {
      return el0.x < el1.x + el1.width &&
             el0.x + el0.width > el1.x &&
             el0.y < el1.y + el1.height &&
             el0.height + el0.y > el1.y;
  }

  function bounceOffCollidables(el0, el1) { // WIP
    // bounce off walls
    
    if (!haveCollided(el0, el1)) return;
    
    const center = el => [
      el.x + el.width/2,
      el.y + el.height/2
    ]

    const [ el0cx, el0cy ] = center(el0);
    const [ el1cx, el1cy ] = center(el1);

    if (el0cx > el1cx) {
      el0.x = el1.x + el1.width;
      el0.vx = el0.vx * (el0.vx*el1.vx < 0 ? -1 : 1)*el0.bounce;
      el0.ax = 0;

      el1.x = el0.x - el1.width;
      el1.vx = el1.vx * (el0.vx*el1.vx < 0 ? 1 : -1)*el1.bounce;
      el1.ax = 0;
    }

    if (el0cy > el1cy) {
      el0.y = el1.y + el1.height;
      el0.vy = el0.vy * (el0.vy*el1.vy < 0 ? -1 : 1)*el0.bounce;
      el0.ay = 0;

      el1.y = el0.y - el1.height;
      el1.vy = el1.vy * (el0.vy*el1.vy < 0 ? 1 : -1)*el1.bounce;
      el1.ay = 0;
    }

  }

  const w = window.innerWidth;
  const h = window.innerHeight;

  function bounceOffWalls(el) {
      const collisionScale = el.bounce
      // bounce off walls
      if (el.x < 0) {
        el.x = 0;
        el.vx = el.vx < 0 ? el.vx*-collisionScale : el.vx*collisionScale;
        el.ax = 0;
      }
    
      if (el.x > w - el.width) {
        el.x = w - el.width;
        el.vx = el.vx > 0 ? el.vx*-collisionScale : el.vx*collisionScale;
        el.ax = 0;
      }

      if (el.y < 0) {
        el.y = 0;
        el.vy = el.vy < 0 ? el.vy*-collisionScale : el.vy*collisionScale;
        el.ay = 0;
      }

      if (el.y > h - el.height) {
        el.y = h - el.height;
        el.vy = el.vy > 0 ? el.vy*-collisionScale : el.vy*collisionScale;
        el.ay = 0;
      }
      
  }

  let mouseX = 0;
  let mouseY = 0;
  let stepCount = 0;
  const heldKeys = {}
  let pressedKeys = {};
  
  function step() {
    for (let i = 0; i < all.length; i++) {
      const el = all[i];
      let [fx, fy] = calculateForce(i)

      el.ax += fx;
      el.ay += fy;

      // full step should I do half step
      el.vx += el.ax * 1/2 - el.vx*el.frictionX;
      el.vy += el.ay * 1/2 - el.vy*el.frictionY;

      // move
      el.x += el.vx;
      el.y += el.vy;

      if (el.func) el.func(el, w, h, mouseX, mouseY, stepCount, heldKeys, pressedKeys);
      for (let evt in el.events) {
        
      }
      el.style.transform = `matrix(1, 0, 0, 1, ${el.x}, ${el.y})`

      
      bounceOffWalls(el)
      
      // half step
      el.vx += el.ax * 1/2 - el.vx*el.frictionX;
      el.vy += el.ay * 1/2 - el.vy*el.frictionY;

    }

    for (let key in pressedKeys) {
      if (heldKeys[key]) pressedKeys[key] = false;
    }

    
    // for (let i = 0; i < collidables.length; i++) {
    //   for (let j = i+1; j < collidables.length; j++) {
    //     let el0 = collidables[i];
    //     let el1 = collidables[j];
    //     bounceOffCollidables(el0, el1);
    //   }
    // }

    stepCount++;
  }

  document.addEventListener("mousemove", e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  })

  document.addEventListener("keydown", e => {
    const key = e.key;

    if (heldKeys[key]) return;

    heldKeys[key] = true;
    pressedKeys[key] = true;
  })

  document.addEventListener("keyup", e => {
    const key = e.key;
    delete heldKeys[key];
  })

  // setInterval(step, 1000/20)

  const animate = () => {
    step();
    window.requestAnimationFrame(animate);
  }

  animate();
</script>












